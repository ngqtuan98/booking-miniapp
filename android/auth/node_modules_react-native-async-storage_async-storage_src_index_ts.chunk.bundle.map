{"version":3,"file":"node_modules_react-native-async-storage_async-storage_src_index_ts.chunk.bundle","mappings":"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","sources":["webpack:///./node_modules/@react-native-async-storage/async-storage/src/AsyncStorage.native.ts","webpack:///./node_modules/@react-native-async-storage/async-storage/src/RCTAsyncStorage.ts","webpack:///./node_modules/@react-native-async-storage/async-storage/src/helpers.ts","webpack:///./node_modules/@react-native-async-storage/async-storage/src/hooks.ts","webpack:///./node_modules/@react-native-async-storage/async-storage/src/index.ts","webpack:///./node_modules/@react-native-async-storage/async-storage/src/shouldFallbackToLegacyNativeModule.ts"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  checkValidArgs,\n  checkValidInput,\n  convertError,\n  convertErrors,\n} from './helpers';\nimport RCTAsyncStorage from './RCTAsyncStorage';\nimport type {\n  AsyncStorageStatic,\n  ErrorLike,\n  KeyValuePair,\n  MultiRequest,\n} from './types';\n\nif (!RCTAsyncStorage) {\n  throw new Error(`[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null.\n\nTo fix this issue try these steps:\n\n  • Rebuild and restart the app.\n\n  • Run the packager with \\`--reset-cache\\` flag.\n\n  • If you are using CocoaPods on iOS, run \\`pod install\\` in the \\`ios\\` directory and then rebuild and re-run the app.\n\n  • If this happens while testing with Jest, check out docs how to integrate AsyncStorage with it: https://react-native-async-storage.github.io/async-storage/docs/advanced/jest\n\nIf none of these fix the issue, please open an issue on the Github repository: https://github.com/react-native-async-storage/async-storage/issues\n`);\n}\n\n/**\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\n * storage system that is global to the app. It should be used instead of\n * LocalStorage.\n *\n * See https://react-native-async-storage.github.io/async-storage/docs/api\n */\nconst AsyncStorage = ((): AsyncStorageStatic => {\n  let _getRequests: MultiRequest[] = [];\n  let _getKeys: string[] = [];\n  let _immediate: ReturnType<typeof setImmediate> | null = null;\n\n  return {\n    /**\n     * Fetches an item for a `key` and invokes a callback upon completion.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\n     */\n    getItem: (key, callback) => {\n      return new Promise((resolve, reject) => {\n        checkValidInput(key);\n        RCTAsyncStorage.multiGet(\n          [key],\n          (errors?: ErrorLike[], result?: string[][]) => {\n            // Unpack result to get value from [[key,value]]\n            const value = result?.[0]?.[1] ? result[0][1] : null;\n            const errs = convertErrors(errors);\n            callback?.(errs?.[0], value);\n            if (errs) {\n              reject(errs[0]);\n            } else {\n              resolve(value);\n            }\n          }\n        );\n      });\n    },\n\n    /**\n     * Sets the value for a `key` and invokes a callback upon completion.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\n     */\n    setItem: (key, value, callback) => {\n      return new Promise((resolve, reject) => {\n        checkValidInput(key, value);\n        RCTAsyncStorage.multiSet([[key, value]], (errors?: ErrorLike[]) => {\n          const errs = convertErrors(errors);\n          callback?.(errs?.[0]);\n          if (errs) {\n            reject(errs[0]);\n          } else {\n            resolve();\n          }\n        });\n      });\n    },\n\n    /**\n     * Removes an item for a `key` and invokes a callback upon completion.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\n     */\n    removeItem: (key, callback) => {\n      return new Promise((resolve, reject) => {\n        checkValidInput(key);\n        RCTAsyncStorage.multiRemove([key], (errors?: ErrorLike[]) => {\n          const errs = convertErrors(errors);\n          callback?.(errs?.[0]);\n          if (errs) {\n            reject(errs[0]);\n          } else {\n            resolve();\n          }\n        });\n      });\n    },\n\n    /**\n     * Merges an existing `key` value with an input value, assuming both values\n     * are stringified JSON.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\n     */\n    mergeItem: (key, value, callback) => {\n      return new Promise((resolve, reject) => {\n        checkValidInput(key, value);\n        RCTAsyncStorage.multiMerge([[key, value]], (errors?: ErrorLike[]) => {\n          const errs = convertErrors(errors);\n          callback?.(errs?.[0]);\n          if (errs) {\n            reject(errs[0]);\n          } else {\n            resolve();\n          }\n        });\n      });\n    },\n\n    /**\n     * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\n     * don't want to call this; use `removeItem` or `multiRemove` to clear only\n     * your app's keys.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\n     */\n    clear: (callback) => {\n      return new Promise((resolve, reject) => {\n        RCTAsyncStorage.clear((error?: ErrorLike) => {\n          const err = convertError(error);\n          callback?.(err);\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    },\n\n    /**\n     * Gets *all* keys known to your app; for all callers, libraries, etc.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\n     */\n    getAllKeys: (callback) => {\n      return new Promise((resolve, reject) => {\n        RCTAsyncStorage.getAllKeys((error?: ErrorLike, keys?: string[]) => {\n          const err = convertError(error);\n          callback?.(err, keys);\n          if (keys) {\n            resolve(keys);\n          } else {\n            reject(err);\n          }\n        });\n      });\n    },\n\n    /**\n     * The following batched functions are useful for executing a lot of\n     * operations at once, allowing for native optimizations and provide the\n     * convenience of a single callback after all operations are complete.\n     *\n     * These functions return arrays of errors, potentially one for every key.\n     * For key-specific errors, the Error object will have a key property to\n     * indicate which key caused the error.\n     */\n\n    /**\n     * Flushes any pending requests using a single batch call to get the data.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\n     * */\n    flushGetRequests: () => {\n      const getRequests = _getRequests;\n      const getKeys = _getKeys;\n\n      _getRequests = [];\n      _getKeys = [];\n\n      RCTAsyncStorage.multiGet(\n        getKeys,\n        (errors?: ErrorLike[], result?: string[][]) => {\n          // Even though the runtime complexity of this is theoretically worse vs if we used a map,\n          // it's much, much faster in practice for the data sets we deal with (we avoid\n          // allocating result pair arrays). This was heavily benchmarked.\n          //\n          // Is there a way to avoid using the map but fix the bug in this breaking test?\n          // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\n          const map: Record<string, string> = {};\n          result?.forEach(([key, value]) => {\n            map[key] = value;\n            return value;\n          });\n          const reqLength = getRequests.length;\n\n          /**\n           * As mentioned few lines above, this method could be called with the array of potential error,\n           * in case of anything goes wrong. The problem is, if any of the batched calls fails\n           * the rest of them would fail too, but the error would be consumed by just one. The rest\n           * would simply return `undefined` as their result, rendering false negatives.\n           *\n           * In order to avoid this situation, in case of any call failing,\n           * the rest of them will be rejected as well (with the same error).\n           */\n          const errorList = convertErrors(errors);\n          const error = errorList?.length ? errorList[0] : null;\n\n          for (let i = 0; i < reqLength; i++) {\n            const request = getRequests[i];\n            if (error) {\n              request.callback?.(errorList);\n              request.reject?.(error);\n              continue;\n            }\n            const requestResult = request.keys.map<KeyValuePair>((key) => [\n              key,\n              map[key],\n            ]);\n            request.callback?.(null, requestResult);\n            request.resolve?.(requestResult);\n          }\n        }\n      );\n    },\n\n    /**\n     * This allows you to batch the fetching of items given an array of `key`\n     * inputs. Your callback will be invoked with an array of corresponding\n     * key-value pairs found.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\n     */\n    multiGet: (keys, callback) => {\n      if (!_immediate) {\n        _immediate = setImmediate(() => {\n          _immediate = null;\n          AsyncStorage.flushGetRequests();\n        });\n      }\n\n      const getRequest: MultiRequest = {\n        keys: keys,\n        callback: callback,\n        // do we need this?\n        keyIndex: _getKeys.length,\n        resolve: null as any,\n        reject: null as any,\n      };\n\n      const promiseResult = new Promise<readonly KeyValuePair[]>(\n        (resolve, reject) => {\n          getRequest.resolve = resolve;\n          getRequest.reject = reject;\n        }\n      );\n\n      _getRequests.push(getRequest);\n      // avoid fetching duplicates\n      keys.forEach((key) => {\n        if (_getKeys.indexOf(key) === -1) {\n          _getKeys.push(key);\n        }\n      });\n\n      return promiseResult;\n    },\n\n    /**\n     * Use this as a batch operation for storing multiple key-value pairs. When\n     * the operation completes you'll get a single callback with any errors.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\n     */\n    multiSet: (keyValuePairs, callback) => {\n      checkValidArgs(keyValuePairs, callback);\n      return new Promise((resolve, reject) => {\n        keyValuePairs.forEach(([key, value]) => {\n          checkValidInput(key, value);\n        });\n\n        RCTAsyncStorage.multiSet(keyValuePairs, (errors?: ErrorLike[]) => {\n          const error = convertErrors(errors);\n          callback?.(error);\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      });\n    },\n\n    /**\n     * Call this to batch the deletion of all keys in the `keys` array.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\n     */\n    multiRemove: (keys, callback) => {\n      return new Promise((resolve, reject) => {\n        keys.forEach((key) => checkValidInput(key));\n\n        RCTAsyncStorage.multiRemove(keys, (errors?: ErrorLike[]) => {\n          const error = convertErrors(errors);\n          callback?.(error);\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      });\n    },\n\n    /**\n     * Batch operation to merge in existing and new values for a given set of\n     * keys. This assumes that the values are stringified JSON.\n     *\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\n     */\n    multiMerge: (keyValuePairs, callback) => {\n      return new Promise((resolve, reject) => {\n        RCTAsyncStorage.multiMerge(keyValuePairs, (errors?: ErrorLike[]) => {\n          const error = convertErrors(errors);\n          callback?.(error);\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      });\n    },\n  };\n})();\n\nexport default AsyncStorage;\n","// @ts-ignore Module '\"react-native\"' has no exported member 'TurboModuleRegistry'.\nimport { NativeModules, TurboModuleRegistry } from 'react-native';\nimport { shouldFallbackToLegacyNativeModule } from './shouldFallbackToLegacyNativeModule';\n\nlet RCTAsyncStorage =\n  NativeModules['PlatformLocalStorage'] || // Support for external modules, like react-native-windows\n  NativeModules['RNC_AsyncSQLiteDBStorage'] ||\n  NativeModules['RNCAsyncStorage'];\n\nif (!RCTAsyncStorage && shouldFallbackToLegacyNativeModule()) {\n  // TurboModuleRegistry falls back to NativeModules so we don't have to try go\n  // assign NativeModules' counterparts if TurboModuleRegistry would resolve\n  // with undefined.\n  if (TurboModuleRegistry) {\n    RCTAsyncStorage =\n      TurboModuleRegistry.get('AsyncSQLiteDBStorage') ||\n      TurboModuleRegistry.get('AsyncLocalStorage');\n  } else {\n    RCTAsyncStorage =\n      NativeModules['AsyncSQLiteDBStorage'] ||\n      NativeModules['AsyncLocalStorage'];\n  }\n}\n\nexport default RCTAsyncStorage;\n","import type { ErrorLike } from './types';\n\nexport function checkValidArgs(keyValuePairs: unknown[], callback: unknown) {\n  if (\n    !Array.isArray(keyValuePairs) ||\n    keyValuePairs.length === 0 ||\n    !Array.isArray(keyValuePairs[0])\n  ) {\n    throw new Error(\n      '[AsyncStorage] Expected array of key-value pairs as first argument to multiSet'\n    );\n  }\n\n  if (callback && typeof callback !== 'function') {\n    if (Array.isArray(callback)) {\n      throw new Error(\n        '[AsyncStorage] Expected function as second argument to multiSet. Did you forget to wrap key-value pairs in an array for the first argument?'\n      );\n    }\n\n    throw new Error(\n      '[AsyncStorage] Expected function as second argument to multiSet'\n    );\n  }\n}\n\nexport function checkValidInput(...input: unknown[]) {\n  const [key, value] = input;\n\n  if (typeof key !== 'string') {\n    console.warn(\n      `[AsyncStorage] Using ${typeof key} type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\\nKey passed: ${key}\\n`\n    );\n  }\n\n  if (input.length > 1 && typeof value !== 'string') {\n    if (value == null) {\n      throw new Error(\n        `[AsyncStorage] Passing null/undefined as value is not supported. If you want to remove value, Use .removeItem method instead.\\nPassed value: ${value}\\nPassed key: ${key}\\n`\n      );\n    } else {\n      console.warn(\n        `[AsyncStorage] The value for key \"${key}\" is not a string. This can lead to unexpected behavior/errors. Consider stringifying it.\\nPassed value: ${value}\\nPassed key: ${key}\\n`\n      );\n    }\n  }\n}\n\nexport function convertError(error?: ErrorLike): Error | null {\n  if (!error) {\n    return null;\n  }\n\n  const out = new Error(error.message);\n  (out as any).key = error.key;\n  return out;\n}\n\nexport function convertErrors(\n  errs?: ErrorLike[]\n): ReadonlyArray<Error | null> | null {\n  const errors = ensureArray(errs);\n  return errors ? errors.map((e) => convertError(e)) : null;\n}\n\nfunction ensureArray(e?: ErrorLike | ErrorLike[]): ErrorLike[] | null {\n  if (Array.isArray(e)) {\n    return e.length === 0 ? null : e;\n  } else if (e) {\n    return [e];\n  } else {\n    return null;\n  }\n}\n","import AsyncStorage from './AsyncStorage';\nimport type { AsyncStorageHook } from './types';\n\nexport function useAsyncStorage(key: string): AsyncStorageHook {\n  return {\n    getItem: (...args) => AsyncStorage.getItem(key, ...args),\n    setItem: (...args) => AsyncStorage.setItem(key, ...args),\n    mergeItem: (...args) => AsyncStorage.mergeItem(key, ...args),\n    removeItem: (...args) => AsyncStorage.removeItem(key, ...args),\n  };\n}\n","import AsyncStorage from './AsyncStorage';\n\nexport { useAsyncStorage } from './hooks';\n\nexport type { AsyncStorageStatic } from './types';\n\nexport default AsyncStorage;\n","import { NativeModules } from 'react-native';\n\nexport function shouldFallbackToLegacyNativeModule(): boolean {\n  const expoConstants =\n    NativeModules['NativeUnimoduleProxy']?.modulesConstants?.ExponentConstants;\n\n  if (expoConstants) {\n    /**\n     * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.\n     * In bare React Native apps using expo-constants, appOwnership is never defined, so\n     * isLegacySdkVersion will be false in that context.\n     */\n    const isLegacySdkVersion =\n      expoConstants.appOwnership && !expoConstants.executionEnvironment;\n\n    /**\n     * Expo managed apps don't include the @react-native-async-storage/async-storage\n     * native modules yet, but the API interface is the same, so we can use the version\n     * exported from React Native still.\n     *\n     * If in future releases (eg: @react-native-async-storage/async-storage >= 2.0.0) this\n     * will likely not be valid anymore, and the package will need to be included in the Expo SDK\n     * to continue to work.\n     */\n    if (\n      isLegacySdkVersion ||\n      ['storeClient', 'standalone'].includes(expoConstants.executionEnvironment)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"names":["RCTAsyncStorage","Error","_getRequests","_getKeys","_immediate","AsyncStorage","getItem","key","callback","Promise","resolve","reject","checkValidInput","multiGet","errors","result","value","errs","convertErrors","setItem","multiSet","removeItem","multiRemove","mergeItem","multiMerge","clear","error","err","convertError","getAllKeys","keys","flushGetRequests","getRequests","getKeys","map","forEach","reqLength","length","errorList","i","request","requestResult","setImmediate","getRequest","keyIndex","promiseResult","push","indexOf","keyValuePairs","checkValidArgs","NativeModules","shouldFallbackToLegacyNativeModule","TurboModuleRegistry","get","out","message","Array","isArray","input","console","warn","e","args","expoConstants","modulesConstants","ExponentConstants","appOwnership","executionEnvironment","includes"],"sourceRoot":""}